import copy
#from numpy import product

from odoo import _, api, models, fields
from odoo.exceptions import UserError

# from odoo.tools import float_compare, float_round

class MrpProduction(models.Model):
    _inherit = "mrp.production"

    @api.depends('move_raw_ids', 'is_locked', 'state', 'move_raw_ids.quantity_done')
    def _compute_unreserve_visible(self):
        for order in self:
            order.unreserve_visible = True

    # def action_assign(self):
    #     self.unreserve_visible = True
    #     return super(MrpProduction, self).action_assign()
    # for move_r in self.env['stock.move.line'].search([('production_id', '=', self.id)]):
    #     if move_r.state not in ('done','cancel','draft') and move_r.product_id.tracking == 'serial':
    #         self._cr.execute("UPDATE stock_move_line SET lot_id = NULL WHERE id = %s",[move_r.id])
    # return res


#
#     def action_cancel(self):
#         """ Cancels production order, unfinished stock moves and set procurement
#         orders in exception """
#         for mv_r in self.move_raw_ids:
#             mv_r.state = 'cancel'
#         return super(MrpProduction, self).action_cancel()

class MrpRoutingWorkcenter(models.Model):
    _inherit = "mrp.routing.workcenter"

    print_qr = fields.Boolean(
        string="Print QR",
        store=True
    )
    print_label = fields.Boolean(
        string="Print Packaging Label",
        store=True
    )


class MrpWorkOrder(models.Model):
    _inherit = 'mrp.workorder'

    finished_product_check_ids = fields.Many2many('quality.check', compute='_compute_finished_product_check_ids')
    product_name = fields.Char()
    is_rieju = fields.Boolean('Product RIEJU', compute='_compute_rieju')
    is_auto = fields.Boolean(related='finished_lot_id.is_autogenerated')
    is_mac = fields.Boolean('Product MAC', compute='_compute_device')
    is_dev = fields.Boolean('Product DEV', compute='_compute_device')

    print_qr = fields.Boolean(
        related='operation_id.print_qr',
        string="Print QR",
        store=True
    )
    print_label = fields.Boolean(
        related='operation_id.print_label',
        string="Print Packaging Label",
        store=True
    )
    do_return = fields.Boolean(
        string='Do return',
        default=False
    )
    last_finished_lot_id = fields.Many2one(
        'stock.production.lot', string='Last Lot/Serial Number',
        domain="[('product_id', '=', product_id), ('company_id', '=', company_id)]", check_company=True)

    @api.depends('product_id')
    def _compute_rieju(self):
        for wo in self:
            wo.is_rieju = True if 'rieju' in wo.product_id.name.lower() else False

    @api.depends('component_id')
    def _compute_device(self):
        pmac = self.env.ref('gst_lvl_connector_aws.product_product_serial_macid')
        pdev = self.env.ref('gst_lvl_connector_aws.product_product_serial_imei')
        for wo in self:
            ismac = isdev = False
            if wo.component_id:
                if pdev == wo.component_id: isdev = True
                if pmac == wo.component_id: ismac = True
            wo.is_dev = isdev
            wo.is_mac = ismac

    @api.depends('check_ids')
    def _compute_finished_product_check_ids(self):
        for wo in self:
            wo.finished_product_check_ids = wo.check_ids.filtered(
                lambda c: c.finished_product_sequence == wo.qty_produced)

            # WIP: Automatization Prod Order with same serial
            # if not wo.finished_lot_id and self.operation_id \
            #         and self.operation_id.print_label:

            #     if not self._check_product_imei(wo.component_id):
            #         wo._set_finished_lot_id()
                    
    def _set_finished_lot_id(self):
        name = self.env['ir.sequence'].next_by_code('product.product')
        if not name:
            raise UserError("No se ha definido la secuencia para Series genéricas")
        self.finished_lot_id = self.env['stock.production.lot'].create(
            {'name': name, 'product_id': self.production_id.product_id.id,
            'company_id': self.production_id.company_id.id})

    def _check_product_imei(self, product):
        dev_name = 'gst_lvl_connector_aws.product_product_serial_imei'
        if self.env.ref(dev_name) == product: return True
        key_name = 'gst_lvl_connector_aws.product_product_serial_macid'
        if self.env.ref(key_name) == product: return True
        return False

    @api.onchange('lot_id')
    def _onchange_lot_id(self):
        if self.lot_id and self._check_product_imei(self.component_id):
            objLot = self.env['stock.production.lot']
            ref = self.lot_id.name
            product = self.production_id.product_id

            if not self.production_id.picking_type_id.use_create_components_lots:
                raise UserError("%s %s %s %s %s" % (
                'Si desea que se genere la secuencia de forma automática debe',
                'ir a "Inventario / Configuración / Tipos de Operaciones",',
                'luego seleccione la Operación de Fabricación que utiliza',
                'actualmente. Dentro del formulario en el apartado',
                '"Trazabilidad" debe marcar la opción "Crear nuevos lotes".'))

            args = [('name', '=', ref), ('product_id', '=', product.id)]
            lot_id = objLot.search(args, limit=1)

            if self.lot_id:   # WIP: Pendiente QA de KEYS por AWS
                if not self.lot_id.product_qty \
                        and (not lot_id or not lot_id.product_qty):
                    raise UserError('Este IMEI no está en stock.')
                self.lot_id._validate_test()    # Check QA Test
            
            # WIP
            if not lot_id:
                type = False
                if self.lot_id.is_mac: type = 'macid'
                if self.lot_id.is_device: type = 'imei'
                cid = self.company_id.id
                lot_id = objLot._create_serial_number(ref, product, cid, type, True)
                # objLot._update_qty_inventory(lot_id, product)
                # objLot._update_qty_inventory(self.lot_id, self.component_id, -1)
            self.finished_lot_id = lot_id.id
        elif self.lot_id and not self.finished_lot_id:
            self._set_finished_lot_id()

    def do_finish(self):
        self.ensure_one()
        self._run_force_links()
        self.write({'do_return': True})
        res = super(MrpWorkOrder, self).do_finish()
        if res and self.operation_id and self.operation_id.print_label:
            report = 'gst_lvl_packaging.report_label_report_packaging_new'
            action_report = self.env.ref(report).report_action(self)
            ctx = self.env.context.copy()
            self.env.context = ctx
            # Fuerzo los movimientos a hecho, segun necesidad del cliente
            self.production_id.post_inventory()
            # Elimino movimientos problematicos
            for move_r in self.env['stock.move.line'].search([('production_id', '=', self.production_id.id)]):
                if move_r.state == 'assigned':
                    move_r.state = 'draft'
                    move_r.unlink()
            return action_report
        return res

    def get_serial_report_basic(self):
        return 'gst_lvl_packaging.report_label_serial_number'

    def get_serial_report_rieju(self):
        return 'gst_lvl_packaging.report_label_serial_number'
        return 'gst_lvl_packaging.' \
                 'report_label_qr_fabrication_lot_imei_plus_mac_new'

    def _search_wol_components(self):
        self.ensure_one()
        return self.raw_workorder_line_ids

    def _get_lots_components(self):
        self.ensure_one()
        wol_lots = self.raw_workorder_line_ids.filtered(lambda r: r.lot_id)
        return wol_lots.mapped('lot_id')

    def _run_force_links(self):
        lots = self._get_lots_components()._set_production_traceability()
        self.finished_lot_id._set_assign_serial(lots)

    def button_print_serial_rieju(self): # RIEJU report Serial Number
        self.ensure_one()
        lots = self._get_lots_components()._set_production_traceability()
        self.finished_lot_id._set_assign_serial(lots)
        return self.finished_lot_id.show_rieju_report()

    def button_print_serial_number(self): # Generic report Serial Number
        self.ensure_one()
        report_name = self.get_serial_report_basic()
        self.action_open_manufacturing_order()
        return self.env.ref(report_name).report_action(self)

    def button_print_qr(self):
        self.ensure_one()
        report = 'gst_lvl_packaging.' \
                 'report_label_qr_fabrication_lot_imei_plus_mac_new'
        return self.env.ref(report).report_action(self)

    def button_print_label(self):
        self.ensure_one() 
        report = 'gst_lvl_packaging.report_label_report_packaging_new'
        return self.env.ref(report).report_action(self)

    # ToDo: Dividir en varias funciones
    def record_production(self):
        self._run_force_links()
        self.last_finished_lot_id = self.finished_lot_id
        res = super(MrpWorkOrder, self).record_production()
        if res and self.operation_id and self.operation_id.print_label:
            self.ensure_one()
            report = 'gst_lvl_packaging.report_label_report_packaging_new'
            action_report = self.env.ref(report).report_action(self)
            ctx = self.env.context.copy()
            self.env.context = ctx
            # Fuerzo los movimientos a hecho, segun necesidad del cliente
            self.production_id.post_inventory()
            # Elimino movimientos problematicos
            for move_r in self.env['stock.move.line'].search([('production_id', '=', self.production_id.id)]):
                if move_r.state == 'assigned':
                    move_r.state = 'draft'
                    move_r.unlink()
            return action_report
        return res

    def button_do_return(self):
        # workorder tree view action should redirect to the same view instead of workorder kanban view when WO mark as done.
        if self.env.context.get('active_model') == self._name:
            action = self.env.ref(
                'mrp.action_mrp_workorder_production_specific').read()[0]
            action['context'] = {
                'search_default_production_id': self.production_id.id}
            action['target'] = 'main'
        else:
            # workorder tablet view action should redirect to the same tablet view with same workcenter when WO mark as done.
            action = \
                self.env.ref('mrp_workorder.mrp_workorder_action_tablet').read()[0]
            action['context'] = {
                'form_view_initial_mode': 'edit',
                'no_breadcrumbs': True,
                'search_default_workcenter_id': self.workcenter_id.id
            }
        action['domain'] = [('state', 'not in', ['done', 'cancel', 'pending'])]
        return action

    def _defaults_from_workorder_lines(self, move, test_type):
        # Check if a workorder line is not filled for this workorder. If it
        # happens select it in order to create quality_check
        self.ensure_one()
        if test_type == 'register_byproducts':
            available_workorder_lines = self.finished_workorder_line_ids.filtered(
                lambda wl: not wl.qty_done and wl.move_id == move)
        else:
            available_workorder_lines = self.raw_workorder_line_ids.filtered(
                lambda wl: not wl.qty_done and wl.move_id == move)
        if available_workorder_lines:
            workorder_line = available_workorder_lines.sorted()[0]
            return {
                'workorder_line_id': workorder_line.id,
                # 'lot_id': workorder_line.lot_id.id,
                # Prefill with 1.0 if it's an extra workorder line.
                'qty_done': workorder_line.qty_to_consume or 1.0
            }
        return {}

    def get_imei(self):
        args = ['|', ('lot_id.is_device', '=', True),
                ('lot_id.device_id', '!=', False)]
        return self._get_serial_number_lnk(args)

    def get_mac(self):
        args = ['|', ('lot_id.is_mac', '=', True),
                ('lot_id.key_id', '!=', False)]
        return self._get_serial_number_lnk(args)

    def _get_serial_number_lnk(self, args):
        if self.raw_workorder_line_ids:
            args += [('raw_workorder_id', '=', self.id)]
            model = 'mrp.workorder.line'
        elif self.move_line_ids:
            args += [('workorder_id', '=', self.id)]
            model = 'stock.move.line'
        else: return ''
        rec_serial = self.env[model].search(args, limit=1, order='id asc')
        return rec_serial.lot_id.name if rec_serial else ""

